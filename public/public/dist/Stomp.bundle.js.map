{"version":3,"sources":["webpack:///Stomp.bundle.js","webpack:///./src/dashboard/lib/stomp.js"],"names":["webpackJsonp","511","module","exports","__webpack_require__","Object","defineProperty","value","Byte","Client","Frame","Stomp","__hasProp","hasOwnProperty","__slice","slice","LF","NULL","command","headers","body","this","unmarshallSingle","prototype","toString","lines","name","_ref","call","push","sizeOfUTF8","join","s","encodeURI","split","length","data","chr","divider","headerLines","i","idx","len","line","start","trim","_i","_j","_len","_ref1","search","RegExp","substring","shift","str","replace","reverse","indexOf","parseInt","charAt","unmarshall","datas","_results","marshall","frame","ws","binaryType","counter","connected","heartbeat","outgoing","incoming","maxWebSocketFrameSize","subscriptions","now","debug","message","window","console","log","Date","valueOf","_transmit","out","send","_setupHeartbeat","serverIncoming","serverOutgoing","ttl","v","_this","version","VERSIONS","V1_1","V1_2","Math","max","pinger","setInterval","ponger","delta","serverActivity","close","_parseConnect","args","connectCallback","errorCallback","arguments","Function","login","passcode","host","connect","apply","onmessage","evt","arr","c","client","messageID","onreceive","subscription","ArrayBuffer","Uint8Array","String","fromCharCode","server","ack","nack","onreceipt","onclose","msg","url","_cleanUp","onopen","supportedVersions","disconnect","disconnectCallback","clearInterval","destination","subscribe","callback","id","unsubscribe","begin","transaction","txid","commit","abort","V1_0","protocols","klass","WebSocketClass","WebSocket","over","interval","f","self","undefined","default"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAGAC,QAAOC,eAAeH,EAAS,cAC3BI,OAAO,ICAX,WACI,GAAIC,GAAMC,EAAQC,EAAOC,EACrBC,KAAeC,eACfC,KAAaC,KAEjBP,IACIQ,GAAI,KACJC,KAAM,MAGVP,EAAS,WAGL,QAASA,GAAMQ,EAASC,EAASC,GAC7BC,KAAKH,QAAUA,EACfG,KAAKF,QAAqB,MAAXA,EAAkBA,KACjCE,KAAKD,KAAe,MAARA,EAAeA,EAAO,GALtC,GAAIE,EAuFJ,OA/EAZ,GAAMa,UAAUC,SAAW,WACvB,GAAIC,GAAOC,EAAMnB,EAAOoB,CACxBF,IAASJ,KAAKH,SACdS,EAAON,KAAKF,OACZ,KAAKO,IAAQC,GACJf,EAAUgB,KAAKD,EAAMD,KAC1BnB,EAAQoB,EAAKD,GACbD,EAAMI,KAAUH,EAAO,IAAMnB,GAMjC,OAJIc,MAAKD,MACLK,EAAMI,KAAK,kBAAqBnB,EAAMoB,WAAWT,KAAKD,OAE1DK,EAAMI,KAAKrB,EAAKQ,GAAKK,KAAKD,MACnBK,EAAMM,KAAKvB,EAAKQ,KAG3BN,EAAMoB,WAAa,SAASE,GACxB,MAAIA,GACOC,UAAUD,GAAGE,MAAM,SAASC,OAAS,EAErC,GAIfb,EAAmB,SAASc,GACxB,GAAIhB,GAAMiB,EAAKnB,EAASoB,EAASC,EAAapB,EAASqB,EAAGC,EAAKC,EAAKC,EAAMC,EAAOC,EAAMC,EAAIC,EAAIC,EAAMrB,EAAMsB,CAS3G,KARAX,EAAUF,EAAKc,OAAOC,OAAO,GAAK3C,EAAKQ,GAAKR,EAAKQ,KACjDuB,EAAcH,EAAKgB,UAAU,EAAGd,GAASJ,MAAM1B,EAAKQ,IACpDE,EAAUqB,EAAYc,QACtBlC,KACA0B,EAAO,SAASS,GACZ,MAAOA,GAAIC,QAAQ,aAAc,KAErC5B,EAAOY,EAAYiB,UACdV,EAAK,EAAGE,EAAOrB,EAAKQ,OAAQW,EAAKE,EAAMF,IACxCH,EAAOhB,EAAKmB,GACZL,EAAME,EAAKc,QAAQ,KACnBtC,EAAQ0B,EAAKF,EAAKS,UAAU,EAAGX,KAASI,EAAKF,EAAKS,UAAUX,EAAM,GAItE,IAFArB,EAAO,GACPwB,EAAQN,EAAU,EACdnB,EAAQ,kBACRuB,EAAMgB,SAASvC,EAAQ,mBACvBC,GAAQ,GAAKgB,GAAMgB,UAAUR,EAAOA,EAAQF,OAG5C,KADAL,EAAM,KACDG,EAAIO,EAAKH,EAAOK,EAAQb,EAAKD,QAAQS,GAASK,EAAQF,EAAKE,EAAQF,EAAKE,KACzEZ,EAAMD,EAAKuB,OAAOnB,MACNhC,EAAKS,KAF+DuB,EAAII,GAASK,IAAUF,IAAOA,EAK9G3B,GAAQiB,CAGhB,OAAO,IAAI3B,GAAMQ,EAASC,EAASC,IAGvCV,EAAMkD,WAAa,SAASC,GACxB,GAAIzB,EACJ,OAAQ,YACJ,GAAIU,GAAIE,EAAMrB,EAAMmC,CAGpB,KAFAnC,EAAOkC,EAAM3B,MAAMiB,OAAO,GAAK3C,EAAKS,KAAOT,EAAKQ,GAAK,MACrD8C,KACKhB,EAAK,EAAGE,EAAOrB,EAAKQ,OAAQW,EAAKE,EAAMF,IACxCV,EAAOT,EAAKmB,IACC,MAARV,EAAeA,EAAKD,WAAS,IAAU,GACxC2B,EAASjC,KAAKP,EAAiBc,GAGvC,OAAO0B,OAIfpD,EAAMqD,SAAW,SAAS7C,EAASC,EAASC,GACxC,GAAI4C,EAEJ,OADAA,GAAQ,GAAItD,GAAMQ,EAASC,EAASC,GAC7B4C,EAAMxC,WAAahB,EAAKS,MAG5BP,KAIXD,EAAU,WAGN,QAASA,GAAOwD,GACZ5C,KAAK4C,GAAKA,EACV5C,KAAK4C,GAAGC,WAAa,cACrB7C,KAAK8C,QAAU,EACf9C,KAAK+C,WAAY,EACjB/C,KAAKgD,WACDC,SAAU,IACVC,SAAU,KAEdlD,KAAKmD,sBAAwB,MAC7BnD,KAAKoD,iBAZT,GAAIC,EAiUJ,OAlTAjE,GAAOc,UAAUoD,MAAQ,SAASC,GAC9B,GAAIjD,EACJ,OAAyB,mBAAXkD,SAAqC,OAAXA,QAA6C,OAA1BlD,EAAOkD,OAAOC,SAAmBnD,EAAKoD,IAAIH,OAAoB,IAG7HF,EAAM,WACF,MAAIM,MAAKN,IACEM,KAAKN,OAEL,GAAIM,OAAOC,SAI1BxE,EAAOc,UAAU2D,UAAY,SAAShE,EAASC,EAASC,GACpD,GAAI+D,EAKJ,KAJAA,EAAMzE,EAAMqD,SAAS7C,EAASC,EAASC,GACb,kBAAfC,MAAKsD,OACZtD,KAAKsD,MAAM,OAASQ,KAEX,CACT,KAAIA,EAAIhD,OAASd,KAAKmD,uBAOlB,MAAOnD,MAAK4C,GAAGmB,KAAKD,EANpB9D,MAAK4C,GAAGmB,KAAKD,EAAI/B,UAAU,EAAG/B,KAAKmD,wBACnCW,EAAMA,EAAI/B,UAAU/B,KAAKmD,uBACC,kBAAfnD,MAAKsD,OACZtD,KAAKsD,MAAM,eAAiBQ,EAAIhD,UAQhD1B,EAAOc,UAAU8D,gBAAkB,SAASlE,GACxC,GAAImE,GAAgBC,EAAgBC,EAAKC,EAAG9D,EAAMsB,EAC9CyC,EAAQrE,IACZ,KAAKM,EAAOR,EAAQwE,WAAahF,EAAMiF,SAASC,MAAQlE,IAAShB,EAAMiF,SAASE,KAuBhF,MApBA7C,GAAS,WACL,GAAIH,GAAIE,EAAMC,EAAOa,CAGrB,KAFAb,EAAQ9B,EAAQ,cAAce,MAAM,KACpC4B,KACKhB,EAAK,EAAGE,EAAOC,EAAMd,OAAQW,EAAKE,EAAMF,IACzC2C,EAAIxC,EAAMH,GACVgB,EAASjC,KAAK6B,SAAS+B,GAE3B,OAAO3B,MACLyB,EAAiBtC,EAAM,GAAIqC,EAAiBrC,EAAM,GACtB,IAA5B5B,KAAKgD,UAAUC,UAAqC,IAAnBgB,IACnCE,EAAMO,KAAKC,IAAI3E,KAAKgD,UAAUC,SAAUgB,GACd,kBAAfjE,MAAKsD,OACZtD,KAAKsD,MAAM,mBAAqBa,EAAM,MAE1CnE,KAAK4E,OAAStF,EAAMuF,YAAYV,EAAK,WAEjC,MADAE,GAAMzB,GAAGmB,KAAK5E,EAAKQ,IACW,kBAAhB0E,GAAMf,MAAuBe,EAAMf,MAAM,gBAAc,MAG3C,IAA5BtD,KAAKgD,UAAUE,UAAqC,IAAnBgB,GACnCC,EAAMO,KAAKC,IAAI3E,KAAKgD,UAAUE,SAAUgB,GACd,kBAAflE,MAAKsD,OACZtD,KAAKsD,MAAM,oBAAsBa,EAAM,MAEpCnE,KAAK8E,OAASxF,EAAMuF,YAAYV,EAAK,WACxC,GAAIY,EAEJ,KADAA,EAAQ1B,IAAQgB,EAAMW,gBACJ,EAANb,EAIR,MAH2B,kBAAhBE,GAAMf,OACbe,EAAMf,MAAM,gDAAkDyB,EAAQ,MAEnEV,EAAMzB,GAAGqC,eAZ5B,IAkBJ7F,EAAOc,UAAUgF,cAAgB,WAC7B,GAAIC,GAAMC,EAAiBC,EAAevF,CAG1C,QAFAqF,EAAO,GAAKG,UAAUxE,OAASrB,EAAQc,KAAK+E,UAAW,MACvDxF,KACQqF,EAAKrE,QACT,IAAK,GACDhB,EAAUqF,EAAK,GAAIC,EAAkBD,EAAK,EAC1C,MACJ,KAAK,GACGA,EAAK,YAAcI,WACnBzF,EAAUqF,EAAK,GAAIC,EAAkBD,EAAK,GAAIE,EAAgBF,EAAK,KAEnErF,EAAQ0F,MAAQL,EAAK,GAAIrF,EAAQ2F,SAAWN,EAAK,GAAIC,EAAkBD,EAAK,GAEhF,MACJ,KAAK,GACDrF,EAAQ0F,MAAQL,EAAK,GAAIrF,EAAQ2F,SAAWN,EAAK,GAAIC,EAAkBD,EAAK,GAAIE,EAAgBF,EAAK,EACrG,MACJ,SACIrF,EAAQ0F,MAAQL,EAAK,GAAIrF,EAAQ2F,SAAWN,EAAK,GAAIC,EAAkBD,EAAK,GAAIE,EAAgBF,EAAK,GAAIrF,EAAQ4F,KAAOP,EAAK,GAErI,OAAQrF,EAASsF,EAAiBC,IAGtCjG,EAAOc,UAAUyF,QAAU,WACvB,GAAIR,GAAME,EAAevF,EAASgE,EAC9BO,EAAQrE,IAqFZ,OApFAmF,GAAO,GAAKG,UAAUxE,OAASrB,EAAQc,KAAK+E,UAAW,MACvDxB,EAAM9D,KAAKkF,cAAcU,MAAM5F,KAAMmF,GACrCrF,EAAUgE,EAAI,GAAI9D,KAAKoF,gBAAkBtB,EAAI,GAAIuB,EAAgBvB,EAAI,GAC3C,kBAAf9D,MAAKsD,OACZtD,KAAKsD,MAAM,yBAEftD,KAAK4C,GAAGiD,UAAY,SAASC,GACzB,GAAIC,GAAKC,EAAGC,EAAQlF,EAAM4B,EAAOuD,EAAWC,EAAWC,EAAc3E,EAAIE,EAAMrB,EAAMmC,CAWrF,IAVA1B,EAA8B,mBAAhBsF,cAA+BP,EAAI/E,eAAgBsF,cAAeN,EAAM,GAAIO,YAAWR,EAAI/E,MAA8B,kBAAhBsD,GAAMf,OAAuBe,EAAMf,MAAM,wBAA0ByC,EAAIjF,QAAoB,WAC9M,GAAIW,GAAIE,EAAMc,CAEd,KADAA,KACKhB,EAAK,EAAGE,EAAOoE,EAAIjF,OAAQW,EAAKE,EAAMF,IACvCuE,EAAID,EAAItE,GACRgB,EAASjC,KAAK+F,OAAOC,aAAaR,GAEtC,OAAOvD,MACL/B,KAAK,KAAOoF,EAAI/E,KACtBsD,EAAMW,eAAiB3B,IACnBtC,IAAS5B,EAAKQ,GAId,YAH2B,kBAAhB0E,GAAMf,OACbe,EAAMf,MAAM,YASpB,KAL2B,kBAAhBe,GAAMf,OACbe,EAAMf,MAAM,OAASvC,GAEzBT,EAAOjB,EAAMkD,WAAWxB,GACxB0B,KACKhB,EAAK,EAAGE,EAAOrB,EAAKQ,OAAQW,EAAKE,EAAMF,IAExC,OADAkB,EAAQrC,EAAKmB,GACLkB,EAAM9C,SACV,IAAK,YAC0B,kBAAhBwE,GAAMf,OACbe,EAAMf,MAAM,uBAAyBX,EAAM7C,QAAQ2G,QAEvDpC,EAAMtB,WAAY,EAClBsB,EAAML,gBAAgBrB,EAAM7C,SAC5B2C,EAASjC,KAAsC,kBAA1B6D,GAAMe,gBAAiCf,EAAMe,gBAAgBzC,OAAS,GAC3F,MACJ,KAAK,UACDyD,EAAezD,EAAM7C,QAAQsG,aAC7BD,EAAY9B,EAAMjB,cAAcgD,IAAiB/B,EAAM8B,UACnDA,GACAF,EAAS5B,EACT6B,EAAYvD,EAAM7C,QAAQ,cAC1B6C,EAAM+D,IAAM,SAAS5G,GAIjB,MAHe,OAAXA,IACAA,MAEGmG,EAAOS,IAAIR,EAAWE,EAActG,IAE/C6C,EAAMgE,KAAO,SAAS7G,GAIlB,MAHe,OAAXA,IACAA,MAEGmG,EAAOU,KAAKT,EAAWE,EAActG,IAEhD2C,EAASjC,KAAK2F,EAAUxD,KAExBF,EAASjC,KAA4B,kBAAhB6D,GAAMf,MAAuBe,EAAMf,MAAM,+BAAiCX,OAAS,GAE5G,MACJ,KAAK,UACDF,EAASjC,KAAgC,kBAApB6D,GAAMuC,UAA2BvC,EAAMuC,UAAUjE,OAAS,GAC/E,MACJ,KAAK,QACDF,EAASjC,KAA8B,kBAAlB6E,GAA+BA,EAAc1C,OAAS,GAC3E,MACJ,SACIF,EAASjC,KAA4B,kBAAhB6D,GAAMf,MAAuBe,EAAMf,MAAM,oBAAsBX,OAAS,IAGzG,MAAOF,IAEXzC,KAAK4C,GAAGiE,QAAU,WACd,GAAIC,EAMJ,OALAA,GAAM,8BAAgCzC,EAAMzB,GAAGmE,IACpB,kBAAhB1C,GAAMf,OACbe,EAAMf,MAAMwD,GAEhBzC,EAAM2C,WAC0B,kBAAlB3B,GAA+BA,EAAcyB,OAAO,IAE/D9G,KAAK4C,GAAGqE,OAAS,WAMpB,MAL2B,kBAAhB5C,GAAMf,OACbe,EAAMf,MAAM,wBAEhBxD,EAAQ,kBAAoBR,EAAMiF,SAAS2C,oBAC3CpH,EAAQ,eAAiBuE,EAAMrB,UAAUC,SAAUoB,EAAMrB,UAAUE,UAAUxC,KAAK,KAC3E2D,EAAMR,UAAU,UAAW/D,KAI1CV,EAAOc,UAAUiH,WAAa,SAASC,EAAoBtH,GAUvD,MATe,OAAXA,IACAA,MAEJE,KAAK6D,UAAU,aAAc/D,GAI7BE,KAAK4C,GAAGqC,QACRjF,KAAKgH,WACgC,kBAAvBI,GAAoCA,QAAuB,IAG7EhI,EAAOc,UAAU8G,SAAW,WAKxB,GAJAhH,KAAK+C,WAAY,EACb/C,KAAK4E,QACLtF,EAAM+H,cAAcrH,KAAK4E,QAEzB5E,KAAK8E,OACL,MAAOxF,GAAM+H,cAAcrH,KAAK8E,SAIxC1F,EAAOc,UAAU6D,KAAO,SAASuD,EAAaxH,EAASC,GAQnD,MAPe,OAAXD,IACAA,MAEQ,MAARC,IACAA,EAAO,IAEXD,EAAQwH,YAAcA,EACftH,KAAK6D,UAAU,OAAQ/D,EAASC,IAG3CX,EAAOc,UAAUqH,UAAY,SAASD,EAAaE,EAAU1H,GACzD,GAAImG,EAWJ,OAVe,OAAXnG,IACAA,MAECA,EAAQ2H,KACT3H,EAAQ2H,GAAK,OAASzH,KAAK8C,WAE/BhD,EAAQwH,YAAcA,EACtBtH,KAAKoD,cAActD,EAAQ2H,IAAMD,EACjCxH,KAAK6D,UAAU,YAAa/D,GAC5BmG,EAASjG,MAELyH,GAAI3H,EAAQ2H,GACZC,YAAa,WACT,MAAOzB,GAAOyB,YAAY5H,EAAQ2H,OAK9CrI,EAAOc,UAAUwH,YAAc,SAASD,GAEpC,aADOzH,MAAKoD,cAAcqE,GACnBzH,KAAK6D,UAAU,eAClB4D,GAAIA,KAIZrI,EAAOc,UAAUyH,MAAQ,SAASC,GAC9B,GAAI3B,GAAQ4B,CAMZ,OALAA,GAAOD,GAAe,MAAQ5H,KAAK8C,UACnC9C,KAAK6D,UAAU,SACX+D,YAAaC,IAEjB5B,EAASjG,MAELyH,GAAII,EACJC,OAAQ,WACJ,MAAO7B,GAAO6B,OAAOD,IAEzBE,MAAO,WACH,MAAO9B,GAAO8B,MAAMF,MAKhCzI,EAAOc,UAAU4H,OAAS,SAASF,GAC/B,MAAO5H,MAAK6D,UAAU,UAClB+D,YAAaA,KAIrBxI,EAAOc,UAAU6H,MAAQ,SAASH,GAC9B,MAAO5H,MAAK6D,UAAU,SAClB+D,YAAaA,KAIrBxI,EAAOc,UAAUwG,IAAM,SAASR,EAAWE,EAActG,GAMrD,MALe,OAAXA,IACAA,MAEJA,EAAQ,cAAgBoG,EACxBpG,EAAQsG,aAAeA,EAChBpG,KAAK6D,UAAU,MAAO/D,IAGjCV,EAAOc,UAAUyG,KAAO,SAAST,EAAWE,EAActG,GAMtD,MALe,OAAXA,IACAA,MAEJA,EAAQ,cAAgBoG,EACxBpG,EAAQsG,aAAeA,EAChBpG,KAAK6D,UAAU,OAAQ/D,IAG3BV,KAIXE,GACIiF,UACIyD,KAAM,MACNxD,KAAM,MACNC,KAAM,MACNyC,kBAAmB,WACf,MAAO,YAGfjB,OAAQ,SAASc,EAAKkB,GAClB,GAAIC,GAAOtF,CAMX,OALiB,OAAbqF,IACAA,GAAa,YAAa,cAE9BC,EAAQ5I,EAAM6I,gBAAkBC,UAChCxF,EAAK,GAAIsF,GAAMnB,EAAKkB,GACb,GAAI7I,GAAOwD,IAEtByF,KAAM,SAASzF,GACX,MAAO,IAAIxD,GAAOwD,IAEtBvD,MAAOA,GAGW,mBAAXmE,SAAqC,OAAXA,QACjClE,EAAMuF,YAAc,SAASyD,EAAUC,GACnC,MAAO/E,QAAOqB,YAAY0D,EAAGD,IAEjChJ,EAAM+H,cAAgB,SAASI,GAC3B,MAAOjE,QAAO6D,cAAcI,IAEhCjE,OAAOlE,MAAQA,OACW,KAAZR,GAAuC,OAAZA,EACzCA,EAAQQ,MAAQA,EAEhBkJ,KAAKlJ,MAAQA,GAGlBiB,SAldHkI,IDseA3J,EAAQ4J,QCjBOpJ","file":"Stomp.bundle.js","sourcesContent":["webpackJsonp([19],{\n\n/***/ 511:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Generated by CoffeeScript 1.6.3\n/*\n   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0\n\n   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)\n   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)\n*/\n\n(function () {\n    var Byte,\n        Client,\n        Frame,\n        Stomp,\n        __hasProp = {}.hasOwnProperty,\n        __slice = [].slice;\n\n    Byte = {\n        LF: '\\x0A',\n        NULL: '\\x00'\n    };\n\n    Frame = function () {\n        var unmarshallSingle;\n\n        function Frame(command, headers, body) {\n            this.command = command;\n            this.headers = headers != null ? headers : {};\n            this.body = body != null ? body : '';\n        }\n\n        Frame.prototype.toString = function () {\n            var lines, name, value, _ref;\n            lines = [this.command];\n            _ref = this.headers;\n            for (name in _ref) {\n                if (!__hasProp.call(_ref, name)) continue;\n                value = _ref[name];\n                lines.push(\"\" + name + \":\" + value);\n            }\n            if (this.body) {\n                lines.push(\"content-length:\" + Frame.sizeOfUTF8(this.body));\n            }\n            lines.push(Byte.LF + this.body);\n            return lines.join(Byte.LF);\n        };\n\n        Frame.sizeOfUTF8 = function (s) {\n            if (s) {\n                return encodeURI(s).split(/%..|./).length - 1;\n            } else {\n                return 0;\n            }\n        };\n\n        unmarshallSingle = function unmarshallSingle(data) {\n            var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;\n            divider = data.search(RegExp(\"\" + Byte.LF + Byte.LF));\n            headerLines = data.substring(0, divider).split(Byte.LF);\n            command = headerLines.shift();\n            headers = {};\n            trim = function trim(str) {\n                return str.replace(/^\\s+|\\s+$/g, '');\n            };\n            _ref = headerLines.reverse();\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                line = _ref[_i];\n                idx = line.indexOf(':');\n                headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n            }\n            body = '';\n            start = divider + 2;\n            if (headers['content-length']) {\n                len = parseInt(headers['content-length']);\n                body = ('' + data).substring(start, start + len);\n            } else {\n                chr = null;\n                for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {\n                    chr = data.charAt(i);\n                    if (chr === Byte.NULL) {\n                        break;\n                    }\n                    body += chr;\n                }\n            }\n            return new Frame(command, headers, body);\n        };\n\n        Frame.unmarshall = function (datas) {\n            var data;\n            return function () {\n                var _i, _len, _ref, _results;\n                _ref = datas.split(RegExp(\"\" + Byte.NULL + Byte.LF + \"*\"));\n                _results = [];\n                for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                    data = _ref[_i];\n                    if ((data != null ? data.length : void 0) > 0) {\n                        _results.push(unmarshallSingle(data));\n                    }\n                }\n                return _results;\n            }();\n        };\n\n        Frame.marshall = function (command, headers, body) {\n            var frame;\n            frame = new Frame(command, headers, body);\n            return frame.toString() + Byte.NULL;\n        };\n\n        return Frame;\n    }();\n\n    Client = function () {\n        var now;\n\n        function Client(ws) {\n            this.ws = ws;\n            this.ws.binaryType = \"arraybuffer\";\n            this.counter = 0;\n            this.connected = false;\n            this.heartbeat = {\n                outgoing: 10000,\n                incoming: 10000\n            };\n            this.maxWebSocketFrameSize = 16 * 1024;\n            this.subscriptions = {};\n        }\n\n        Client.prototype.debug = function (message) {\n            var _ref;\n            return typeof window !== \"undefined\" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;\n        };\n\n        now = function now() {\n            if (Date.now) {\n                return Date.now();\n            } else {\n                return new Date().valueOf;\n            }\n        };\n\n        Client.prototype._transmit = function (command, headers, body) {\n            var out;\n            out = Frame.marshall(command, headers, body);\n            if (typeof this.debug === \"function\") {\n                this.debug(\">>> \" + out);\n            }\n            while (true) {\n                if (out.length > this.maxWebSocketFrameSize) {\n                    this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\n                    out = out.substring(this.maxWebSocketFrameSize);\n                    if (typeof this.debug === \"function\") {\n                        this.debug(\"remaining = \" + out.length);\n                    }\n                } else {\n                    return this.ws.send(out);\n                }\n            }\n        };\n\n        Client.prototype._setupHeartbeat = function (headers) {\n            var serverIncoming,\n                serverOutgoing,\n                ttl,\n                v,\n                _ref,\n                _ref1,\n                _this = this;\n            if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {\n                return;\n            }\n            _ref1 = function () {\n                var _i, _len, _ref1, _results;\n                _ref1 = headers['heart-beat'].split(\",\");\n                _results = [];\n                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n                    v = _ref1[_i];\n                    _results.push(parseInt(v));\n                }\n                return _results;\n            }(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];\n            if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n                ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n                if (typeof this.debug === \"function\") {\n                    this.debug(\"send PING every \" + ttl + \"ms\");\n                }\n                this.pinger = Stomp.setInterval(ttl, function () {\n                    _this.ws.send(Byte.LF);\n                    return typeof _this.debug === \"function\" ? _this.debug(\">>> PING\") : void 0;\n                });\n            }\n            if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n                ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n                if (typeof this.debug === \"function\") {\n                    this.debug(\"check PONG every \" + ttl + \"ms\");\n                }\n                return this.ponger = Stomp.setInterval(ttl, function () {\n                    var delta;\n                    delta = now() - _this.serverActivity;\n                    if (delta > ttl * 2) {\n                        if (typeof _this.debug === \"function\") {\n                            _this.debug(\"did not receive server activity for the last \" + delta + \"ms\");\n                        }\n                        return _this.ws.close();\n                    }\n                });\n            }\n        };\n\n        Client.prototype._parseConnect = function () {\n            var args, connectCallback, errorCallback, headers;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            headers = {};\n            switch (args.length) {\n                case 2:\n                    headers = args[0], connectCallback = args[1];\n                    break;\n                case 3:\n                    if (args[1] instanceof Function) {\n                        headers = args[0], connectCallback = args[1], errorCallback = args[2];\n                    } else {\n                        headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];\n                    }\n                    break;\n                case 4:\n                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];\n                    break;\n                default:\n                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];\n            }\n            return [headers, connectCallback, errorCallback];\n        };\n\n        Client.prototype.connect = function () {\n            var args,\n                errorCallback,\n                headers,\n                out,\n                _this = this;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            out = this._parseConnect.apply(this, args);\n            headers = out[0], this.connectCallback = out[1], errorCallback = out[2];\n            if (typeof this.debug === \"function\") {\n                this.debug(\"Opening Web Socket...\");\n            }\n            this.ws.onmessage = function (evt) {\n                var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;\n                data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === \"function\" ? _this.debug(\"--- got data length: \" + arr.length) : void 0, function () {\n                    var _i, _len, _results;\n                    _results = [];\n                    for (_i = 0, _len = arr.length; _i < _len; _i++) {\n                        c = arr[_i];\n                        _results.push(String.fromCharCode(c));\n                    }\n                    return _results;\n                }().join('')) : evt.data;\n                _this.serverActivity = now();\n                if (data === Byte.LF) {\n                    if (typeof _this.debug === \"function\") {\n                        _this.debug(\"<<< PONG\");\n                    }\n                    return;\n                }\n                if (typeof _this.debug === \"function\") {\n                    _this.debug(\"<<< \" + data);\n                }\n                _ref = Frame.unmarshall(data);\n                _results = [];\n                for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                    frame = _ref[_i];\n                    switch (frame.command) {\n                        case \"CONNECTED\":\n                            if (typeof _this.debug === \"function\") {\n                                _this.debug(\"connected to server \" + frame.headers.server);\n                            }\n                            _this.connected = true;\n                            _this._setupHeartbeat(frame.headers);\n                            _results.push(typeof _this.connectCallback === \"function\" ? _this.connectCallback(frame) : void 0);\n                            break;\n                        case \"MESSAGE\":\n                            subscription = frame.headers.subscription;\n                            onreceive = _this.subscriptions[subscription] || _this.onreceive;\n                            if (onreceive) {\n                                client = _this;\n                                messageID = frame.headers[\"message-id\"];\n                                frame.ack = function (headers) {\n                                    if (headers == null) {\n                                        headers = {};\n                                    }\n                                    return client.ack(messageID, subscription, headers);\n                                };\n                                frame.nack = function (headers) {\n                                    if (headers == null) {\n                                        headers = {};\n                                    }\n                                    return client.nack(messageID, subscription, headers);\n                                };\n                                _results.push(onreceive(frame));\n                            } else {\n                                _results.push(typeof _this.debug === \"function\" ? _this.debug(\"Unhandled received MESSAGE: \" + frame) : void 0);\n                            }\n                            break;\n                        case \"RECEIPT\":\n                            _results.push(typeof _this.onreceipt === \"function\" ? _this.onreceipt(frame) : void 0);\n                            break;\n                        case \"ERROR\":\n                            _results.push(typeof errorCallback === \"function\" ? errorCallback(frame) : void 0);\n                            break;\n                        default:\n                            _results.push(typeof _this.debug === \"function\" ? _this.debug(\"Unhandled frame: \" + frame) : void 0);\n                    }\n                }\n                return _results;\n            };\n            this.ws.onclose = function () {\n                var msg;\n                msg = \"Whoops! Lost connection to \" + _this.ws.url;\n                if (typeof _this.debug === \"function\") {\n                    _this.debug(msg);\n                }\n                _this._cleanUp();\n                return typeof errorCallback === \"function\" ? errorCallback(msg) : void 0;\n            };\n            return this.ws.onopen = function () {\n                if (typeof _this.debug === \"function\") {\n                    _this.debug('Web Socket Opened...');\n                }\n                headers[\"accept-version\"] = Stomp.VERSIONS.supportedVersions();\n                headers[\"heart-beat\"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n                return _this._transmit(\"CONNECT\", headers);\n            };\n        };\n\n        Client.prototype.disconnect = function (disconnectCallback, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            this._transmit(\"DISCONNECT\", headers);\n            // this.ws.onclose = null;\n\n\n            this.ws.close();\n            this._cleanUp();\n            return typeof disconnectCallback === \"function\" ? disconnectCallback() : void 0;\n        };\n\n        Client.prototype._cleanUp = function () {\n            this.connected = false;\n            if (this.pinger) {\n                Stomp.clearInterval(this.pinger);\n            }\n            if (this.ponger) {\n                return Stomp.clearInterval(this.ponger);\n            }\n        };\n\n        Client.prototype.send = function (destination, headers, body) {\n            if (headers == null) {\n                headers = {};\n            }\n            if (body == null) {\n                body = '';\n            }\n            headers.destination = destination;\n            return this._transmit(\"SEND\", headers, body);\n        };\n\n        Client.prototype.subscribe = function (destination, callback, headers) {\n            var client;\n            if (headers == null) {\n                headers = {};\n            }\n            if (!headers.id) {\n                headers.id = \"sub-\" + this.counter++;\n            }\n            headers.destination = destination;\n            this.subscriptions[headers.id] = callback;\n            this._transmit(\"SUBSCRIBE\", headers);\n            client = this;\n            return {\n                id: headers.id,\n                unsubscribe: function unsubscribe() {\n                    return client.unsubscribe(headers.id);\n                }\n            };\n        };\n\n        Client.prototype.unsubscribe = function (id) {\n            delete this.subscriptions[id];\n            return this._transmit(\"UNSUBSCRIBE\", {\n                id: id\n            });\n        };\n\n        Client.prototype.begin = function (transaction) {\n            var client, txid;\n            txid = transaction || \"tx-\" + this.counter++;\n            this._transmit(\"BEGIN\", {\n                transaction: txid\n            });\n            client = this;\n            return {\n                id: txid,\n                commit: function commit() {\n                    return client.commit(txid);\n                },\n                abort: function abort() {\n                    return client.abort(txid);\n                }\n            };\n        };\n\n        Client.prototype.commit = function (transaction) {\n            return this._transmit(\"COMMIT\", {\n                transaction: transaction\n            });\n        };\n\n        Client.prototype.abort = function (transaction) {\n            return this._transmit(\"ABORT\", {\n                transaction: transaction\n            });\n        };\n\n        Client.prototype.ack = function (messageID, subscription, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            headers[\"message-id\"] = messageID;\n            headers.subscription = subscription;\n            return this._transmit(\"ACK\", headers);\n        };\n\n        Client.prototype.nack = function (messageID, subscription, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            headers[\"message-id\"] = messageID;\n            headers.subscription = subscription;\n            return this._transmit(\"NACK\", headers);\n        };\n\n        return Client;\n    }();\n\n    Stomp = {\n        VERSIONS: {\n            V1_0: '1.0',\n            V1_1: '1.1',\n            V1_2: '1.2',\n            supportedVersions: function supportedVersions() {\n                return '1.1,1.0';\n            }\n        },\n        client: function client(url, protocols) {\n            var klass, ws;\n            if (protocols == null) {\n                protocols = ['v10.stomp', 'v11.stomp'];\n            }\n            klass = Stomp.WebSocketClass || WebSocket;\n            ws = new klass(url, protocols);\n            return new Client(ws);\n        },\n        over: function over(ws) {\n            return new Client(ws);\n        },\n        Frame: Frame\n    };\n\n    if (typeof window !== \"undefined\" && window !== null) {\n        Stomp.setInterval = function (interval, f) {\n            return window.setInterval(f, interval);\n        };\n        Stomp.clearInterval = function (id) {\n            return window.clearInterval(id);\n        };\n        window.Stomp = Stomp;\n    } else if (typeof exports !== \"undefined\" && exports !== null) {\n        exports.Stomp = Stomp;\n    } else {\n        self.Stomp = Stomp;\n    }\n}).call(undefined);\n\nexports.default = Stomp;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// Stomp.bundle.js","// Generated by CoffeeScript 1.6.3\n/*\n   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0\n\n   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)\n   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)\n*/\n\n\n(function() {\n    var Byte, Client, Frame, Stomp,\n        __hasProp = {}.hasOwnProperty,\n        __slice = [].slice;\n\n    Byte = {\n        LF: '\\x0A',\n        NULL: '\\x00'\n    };\n\n    Frame = (function() {\n        var unmarshallSingle;\n\n        function Frame(command, headers, body) {\n            this.command = command;\n            this.headers = headers != null ? headers : {};\n            this.body = body != null ? body : '';\n        }\n\n        Frame.prototype.toString = function() {\n            var lines, name, value, _ref;\n            lines = [this.command];\n            _ref = this.headers;\n            for (name in _ref) {\n                if (!__hasProp.call(_ref, name)) continue;\n                value = _ref[name];\n                lines.push(\"\" + name + \":\" + value);\n            }\n            if (this.body) {\n                lines.push(\"content-length:\" + (Frame.sizeOfUTF8(this.body)));\n            }\n            lines.push(Byte.LF + this.body);\n            return lines.join(Byte.LF);\n        };\n\n        Frame.sizeOfUTF8 = function(s) {\n            if (s) {\n                return encodeURI(s).split(/%..|./).length - 1;\n            } else {\n                return 0;\n            }\n        };\n\n        unmarshallSingle = function(data) {\n            var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;\n            divider = data.search(RegExp(\"\" + Byte.LF + Byte.LF));\n            headerLines = data.substring(0, divider).split(Byte.LF);\n            command = headerLines.shift();\n            headers = {};\n            trim = function(str) {\n                return str.replace(/^\\s+|\\s+$/g, '');\n            };\n            _ref = headerLines.reverse();\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                line = _ref[_i];\n                idx = line.indexOf(':');\n                headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n            }\n            body = '';\n            start = divider + 2;\n            if (headers['content-length']) {\n                len = parseInt(headers['content-length']);\n                body = ('' + data).substring(start, start + len);\n            } else {\n                chr = null;\n                for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {\n                    chr = data.charAt(i);\n                    if (chr === Byte.NULL) {\n                        break;\n                    }\n                    body += chr;\n                }\n            }\n            return new Frame(command, headers, body);\n        };\n\n        Frame.unmarshall = function(datas) {\n            var data;\n            return (function() {\n                var _i, _len, _ref, _results;\n                _ref = datas.split(RegExp(\"\" + Byte.NULL + Byte.LF + \"*\"));\n                _results = [];\n                for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                    data = _ref[_i];\n                    if ((data != null ? data.length : void 0) > 0) {\n                        _results.push(unmarshallSingle(data));\n                    }\n                }\n                return _results;\n            })();\n        };\n\n        Frame.marshall = function(command, headers, body) {\n            var frame;\n            frame = new Frame(command, headers, body);\n            return frame.toString() + Byte.NULL;\n        };\n\n        return Frame;\n\n    })();\n\n    Client = (function() {\n        var now;\n\n        function Client(ws) {\n            this.ws = ws;\n            this.ws.binaryType = \"arraybuffer\";\n            this.counter = 0;\n            this.connected = false;\n            this.heartbeat = {\n                outgoing: 10000,\n                incoming: 10000\n            };\n            this.maxWebSocketFrameSize = 16 * 1024;\n            this.subscriptions = {};\n        }\n\n        Client.prototype.debug = function(message) {\n            var _ref;\n            return typeof window !== \"undefined\" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;\n        };\n\n        now = function() {\n            if (Date.now) {\n                return Date.now();\n            } else {\n                return new Date().valueOf;\n            }\n        };\n\n        Client.prototype._transmit = function(command, headers, body) {\n            var out;\n            out = Frame.marshall(command, headers, body);\n            if (typeof this.debug === \"function\") {\n                this.debug(\">>> \" + out);\n            }\n            while (true) {\n                if (out.length > this.maxWebSocketFrameSize) {\n                    this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\n                    out = out.substring(this.maxWebSocketFrameSize);\n                    if (typeof this.debug === \"function\") {\n                        this.debug(\"remaining = \" + out.length);\n                    }\n                } else {\n                    return this.ws.send(out);\n                }\n            }\n        };\n\n        Client.prototype._setupHeartbeat = function(headers) {\n            var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1,\n                _this = this;\n            if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {\n                return;\n            }\n            _ref1 = (function() {\n                var _i, _len, _ref1, _results;\n                _ref1 = headers['heart-beat'].split(\",\");\n                _results = [];\n                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n                    v = _ref1[_i];\n                    _results.push(parseInt(v));\n                }\n                return _results;\n            })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];\n            if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n                ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n                if (typeof this.debug === \"function\") {\n                    this.debug(\"send PING every \" + ttl + \"ms\");\n                }\n                this.pinger = Stomp.setInterval(ttl, function() {\n                    _this.ws.send(Byte.LF);\n                    return typeof _this.debug === \"function\" ? _this.debug(\">>> PING\") : void 0;\n                });\n            }\n            if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n                ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n                if (typeof this.debug === \"function\") {\n                    this.debug(\"check PONG every \" + ttl + \"ms\");\n                }\n                return this.ponger = Stomp.setInterval(ttl, function() {\n                    var delta;\n                    delta = now() - _this.serverActivity;\n                    if (delta > ttl * 2) {\n                        if (typeof _this.debug === \"function\") {\n                            _this.debug(\"did not receive server activity for the last \" + delta + \"ms\");\n                        }\n                        return _this.ws.close();\n                    }\n                });\n            }\n        };\n\n        Client.prototype._parseConnect = function() {\n            var args, connectCallback, errorCallback, headers;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            headers = {};\n            switch (args.length) {\n                case 2:\n                    headers = args[0], connectCallback = args[1];\n                    break;\n                case 3:\n                    if (args[1] instanceof Function) {\n                        headers = args[0], connectCallback = args[1], errorCallback = args[2];\n                    } else {\n                        headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];\n                    }\n                    break;\n                case 4:\n                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];\n                    break;\n                default:\n                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];\n            }\n            return [headers, connectCallback, errorCallback];\n        };\n\n        Client.prototype.connect = function() {\n            var args, errorCallback, headers, out,\n                _this = this;\n            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n            out = this._parseConnect.apply(this, args);\n            headers = out[0], this.connectCallback = out[1], errorCallback = out[2];\n            if (typeof this.debug === \"function\") {\n                this.debug(\"Opening Web Socket...\");\n            }\n            this.ws.onmessage = function(evt) {\n                var arr, c, client, data, frame, messageID, onreceive, subscription, _i, _len, _ref, _results;\n                data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === \"function\" ? _this.debug(\"--- got data length: \" + arr.length) : void 0, ((function() {\n                    var _i, _len, _results;\n                    _results = [];\n                    for (_i = 0, _len = arr.length; _i < _len; _i++) {\n                        c = arr[_i];\n                        _results.push(String.fromCharCode(c));\n                    }\n                    return _results;\n                })()).join('')) : evt.data;\n                _this.serverActivity = now();\n                if (data === Byte.LF) {\n                    if (typeof _this.debug === \"function\") {\n                        _this.debug(\"<<< PONG\");\n                    }\n                    return;\n                }\n                if (typeof _this.debug === \"function\") {\n                    _this.debug(\"<<< \" + data);\n                }\n                _ref = Frame.unmarshall(data);\n                _results = [];\n                for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                    frame = _ref[_i];\n                    switch (frame.command) {\n                        case \"CONNECTED\":\n                            if (typeof _this.debug === \"function\") {\n                                _this.debug(\"connected to server \" + frame.headers.server);\n                            }\n                            _this.connected = true;\n                            _this._setupHeartbeat(frame.headers);\n                            _results.push(typeof _this.connectCallback === \"function\" ? _this.connectCallback(frame) : void 0);\n                            break;\n                        case \"MESSAGE\":\n                            subscription = frame.headers.subscription;\n                            onreceive = _this.subscriptions[subscription] || _this.onreceive;\n                            if (onreceive) {\n                                client = _this;\n                                messageID = frame.headers[\"message-id\"];\n                                frame.ack = function(headers) {\n                                    if (headers == null) {\n                                        headers = {};\n                                    }\n                                    return client.ack(messageID, subscription, headers);\n                                };\n                                frame.nack = function(headers) {\n                                    if (headers == null) {\n                                        headers = {};\n                                    }\n                                    return client.nack(messageID, subscription, headers);\n                                };\n                                _results.push(onreceive(frame));\n                            } else {\n                                _results.push(typeof _this.debug === \"function\" ? _this.debug(\"Unhandled received MESSAGE: \" + frame) : void 0);\n                            }\n                            break;\n                        case \"RECEIPT\":\n                            _results.push(typeof _this.onreceipt === \"function\" ? _this.onreceipt(frame) : void 0);\n                            break;\n                        case \"ERROR\":\n                            _results.push(typeof errorCallback === \"function\" ? errorCallback(frame) : void 0);\n                            break;\n                        default:\n                            _results.push(typeof _this.debug === \"function\" ? _this.debug(\"Unhandled frame: \" + frame) : void 0);\n                    }\n                }\n                return _results;\n            };\n            this.ws.onclose = function() {\n                var msg;\n                msg = \"Whoops! Lost connection to \" + _this.ws.url;\n                if (typeof _this.debug === \"function\") {\n                    _this.debug(msg);\n                }\n                _this._cleanUp();\n                return typeof errorCallback === \"function\" ? errorCallback(msg) : void 0;\n            };\n            return this.ws.onopen = function() {\n                if (typeof _this.debug === \"function\") {\n                    _this.debug('Web Socket Opened...');\n                }\n                headers[\"accept-version\"] = Stomp.VERSIONS.supportedVersions();\n                headers[\"heart-beat\"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n                return _this._transmit(\"CONNECT\", headers);\n            };\n        };\n\n        Client.prototype.disconnect = function(disconnectCallback, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            this._transmit(\"DISCONNECT\", headers);\n            // this.ws.onclose = null;\n\n\n            this.ws.close();\n            this._cleanUp();\n            return typeof disconnectCallback === \"function\" ? disconnectCallback() : void 0;\n        };\n\n        Client.prototype._cleanUp = function() {\n            this.connected = false;\n            if (this.pinger) {\n                Stomp.clearInterval(this.pinger);\n            }\n            if (this.ponger) {\n                return Stomp.clearInterval(this.ponger);\n            }\n        };\n\n        Client.prototype.send = function(destination, headers, body) {\n            if (headers == null) {\n                headers = {};\n            }\n            if (body == null) {\n                body = '';\n            }\n            headers.destination = destination;\n            return this._transmit(\"SEND\", headers, body);\n        };\n\n        Client.prototype.subscribe = function(destination, callback, headers) {\n            var client;\n            if (headers == null) {\n                headers = {};\n            }\n            if (!headers.id) {\n                headers.id = \"sub-\" + this.counter++;\n            }\n            headers.destination = destination;\n            this.subscriptions[headers.id] = callback;\n            this._transmit(\"SUBSCRIBE\", headers);\n            client = this;\n            return {\n                id: headers.id,\n                unsubscribe: function() {\n                    return client.unsubscribe(headers.id);\n                }\n            };\n        };\n\n        Client.prototype.unsubscribe = function(id) {\n            delete this.subscriptions[id];\n            return this._transmit(\"UNSUBSCRIBE\", {\n                id: id\n            });\n        };\n\n        Client.prototype.begin = function(transaction) {\n            var client, txid;\n            txid = transaction || \"tx-\" + this.counter++;\n            this._transmit(\"BEGIN\", {\n                transaction: txid\n            });\n            client = this;\n            return {\n                id: txid,\n                commit: function() {\n                    return client.commit(txid);\n                },\n                abort: function() {\n                    return client.abort(txid);\n                }\n            };\n        };\n\n        Client.prototype.commit = function(transaction) {\n            return this._transmit(\"COMMIT\", {\n                transaction: transaction\n            });\n        };\n\n        Client.prototype.abort = function(transaction) {\n            return this._transmit(\"ABORT\", {\n                transaction: transaction\n            });\n        };\n\n        Client.prototype.ack = function(messageID, subscription, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            headers[\"message-id\"] = messageID;\n            headers.subscription = subscription;\n            return this._transmit(\"ACK\", headers);\n        };\n\n        Client.prototype.nack = function(messageID, subscription, headers) {\n            if (headers == null) {\n                headers = {};\n            }\n            headers[\"message-id\"] = messageID;\n            headers.subscription = subscription;\n            return this._transmit(\"NACK\", headers);\n        };\n\n        return Client;\n\n    })();\n\n    Stomp = {\n        VERSIONS: {\n            V1_0: '1.0',\n            V1_1: '1.1',\n            V1_2: '1.2',\n            supportedVersions: function() {\n                return '1.1,1.0';\n            }\n        },\n        client: function(url, protocols) {\n            var klass, ws;\n            if (protocols == null) {\n                protocols = ['v10.stomp', 'v11.stomp'];\n            }\n            klass = Stomp.WebSocketClass || WebSocket;\n            ws = new klass(url, protocols);\n            return new Client(ws);\n        },\n        over: function(ws) {\n            return new Client(ws);\n        },\n        Frame: Frame\n    };\n\n    if (typeof window !== \"undefined\" && window !== null) {\n        Stomp.setInterval = function(interval, f) {\n            return window.setInterval(f, interval);\n        };\n        Stomp.clearInterval = function(id) {\n            return window.clearInterval(id);\n        };\n        window.Stomp = Stomp;\n    } else if (typeof exports !== \"undefined\" && exports !== null) {\n        exports.Stomp = Stomp;\n    } else {\n        self.Stomp = Stomp;\n    }\n\n}).call(this);\n\n\nexport default Stomp;\n\n\n// WEBPACK FOOTER //\n// ./src/dashboard/lib/stomp.js"],"sourceRoot":""}